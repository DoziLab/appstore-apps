#cloud-config
package_update: true
package_upgrade: false

packages:
  - libpam-pwquality
  - python3
  - cloud-guest-utils

# Ensure root partition/filesystem grows when booting from larger volume
growpart:
  mode: auto
  devices: ["/"]
  ignore_growroot_disabled: false

resize_rootfs: true

write_files:
  - path: /etc/dozilab/user.json.payload
    owner: root:root
    permissions: "0600"
    content: |
      __USER_JSON__
  - path: /usr/local/bin/dozilab-multiuser-setup.sh
    permissions: "0755"
    content: |
      #!/usr/bin/env bash
      set -euo pipefail

      LOG="/var/log/dozilab-multiuser.log"
      MARK_DIR="/var/lib/dozilab"
      READY_FILE="${MARK_DIR}/ready"
      FAIL_FILE="${MARK_DIR}/failed"

      STACK_LABEL="__STACK_LABEL__"

      USER_JSON_PAYLOAD="/etc/dozilab/user.json.payload"
      USER_JSON_PATH="/etc/dozilab/user.json"
      FORCE="__FORCE_CHANGE__"
      WORKDIR="__WORKDIR__"

      PW_MIN_LENGTH="__PW_MIN_LENGTH__"
      PW_REQUIRE_DIGIT="__PW_REQUIRE_DIGIT__"
      PW_REQUIRE_UPPER="__PW_REQUIRE_UPPER__"
      PW_REQUIRE_SPECIAL="__PW_REQUIRE_SPECIAL__"

      mkdir -p "$MARK_DIR"
      # Mirror logs to cloud-init output and our own logfile
      exec > >(tee -a "$LOG" /var/log/cloud-init-output.log) 2>&1
      echo "multiuser setup started $(date -Is)"

      on_fail() {
        rc=$?
        msg="DOZILAB_FAILED stack=${STACK_LABEL} rc=${rc} time=$(date -Is)"
        echo "$msg" | tee -a "$LOG" | tee /dev/console > "$FAIL_FILE"
        chmod 644 "$FAIL_FILE" || true
        exit "$rc"
      }
      trap on_fail ERR

      to_bool() {
        local v="${1:-}"
        v="$(echo "$v" | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')"
        [[ "$v" == "1" || "$v" == "true" || "$v" == "yes" || "$v" == "on" ]]
      }

      # --- Build deterministic pwquality options from Heat params ---
      DCREDIT=0
      UCREDIT=0
      OCREDIT=0
      if to_bool "$PW_REQUIRE_DIGIT"; then DCREDIT=-1; fi
      if to_bool "$PW_REQUIRE_UPPER"; then UCREDIT=-1; fi
      if to_bool "$PW_REQUIRE_SPECIAL"; then OCREDIT=-1; fi
      if ! [[ "$PW_MIN_LENGTH" =~ ^[0-9]+$ ]]; then PW_MIN_LENGTH=12; fi

      # Enforce exactly what the UI exposes (no dict/diff surprise checks)
      # NOTE: this affects password setting (chpasswd) AND interactive passwd.
      PWQ_OPTS="retry=3 enforce_for_root minlen=${PW_MIN_LENGTH} dcredit=${DCREDIT} ucredit=${UCREDIT} ocredit=${OCREDIT} dictcheck=0 usercheck=0 gecoscheck=0 difok=0 maxrepeat=0 minclass=0"

      # Keep pwquality.conf consistent for debugging/inspection (PAM line is the source of truth)
      cat >/etc/security/pwquality.conf <<EOF
      # Managed by DoziLab (cloud-init). NOTE: PAM options override this file.
      minlen = ${PW_MIN_LENGTH}
      dcredit = ${DCREDIT}
      ucredit = ${UCREDIT}
      ocredit = ${OCREDIT}
      dictcheck = 0
      usercheck = 0
      gecoscheck = 0
      difok = 0
      maxrepeat = 0
      minclass = 0
      EOF

      # --- Enforce our exact policy in PAM (source of truth) ---
      PAM_FILE="/etc/pam.d/common-password"

      if grep -qE '^\s*password\s+requisite\s+pam_pwquality\.so' "$PAM_FILE"; then
        # Replace existing pwquality line
        sed -i -E "s|^\s*password\s+requisite\s+pam_pwquality\.so.*$|password requisite pam_pwquality.so ${PWQ_OPTS}|" "$PAM_FILE"
      else
        # Insert before pam_unix
        sed -i -E "/^\s*password\s+.*pam_unix\.so/ i password requisite pam_pwquality.so ${PWQ_OPTS}" "$PAM_FILE"
      fi

      # SSH: enable password login (users use passwords)
      cat >/etc/ssh/sshd_config.d/99-dozilab-multiuser.conf <<'EOF'
      PasswordAuthentication yes
      KbdInteractiveAuthentication yes
      ChallengeResponseAuthentication yes
      UsePAM yes
      PermitRootLogin no
      EOF

      export USER_JSON_PATH FORCE WORKDIR

      if [[ ! -s "$USER_JSON_PAYLOAD" ]]; then
        echo "ERROR: $USER_JSON_PAYLOAD missing/empty" >&2
        exit 2
      fi

      # Decode base64 (or accept raw JSON) into /etc/dozilab/user.json
      python3 - <<'PY'
      import ast
      import base64
      import json
      import sys
      from pathlib import Path

      payload_path = Path("/etc/dozilab/user.json.payload")
      out_path = Path("/etc/dozilab/user.json")

      raw = payload_path.read_text(encoding="utf-8").strip()
      if not raw:
          sys.exit("user_json payload missing/empty")

      def parse_obj(txt: str):
          try:
              return json.loads(txt), "json"
          except Exception:
              pass
          try:
              return ast.literal_eval(txt), "python-literal"
          except Exception:
              return None, None

      def decode_b64(s: str):
          compact = "".join(s.split())
          pad = (-len(compact)) % 4
          compact += "=" * pad
          try:
              return base64.b64decode(compact, validate=True).decode("utf-8")
          except Exception:
              try:
                  return base64.b64decode(compact).decode("utf-8")
              except Exception:
                  return None

      obj, kind = parse_obj(raw)
      source = "raw"
      if obj is None:
          decoded = decode_b64(raw)
          if decoded is None:
              sys.exit("user_json payload is neither JSON/literal nor base64-encoded JSON/literal")
          obj, kind = parse_obj(decoded.strip())
          if obj is None:
              sys.exit("user_json base64 decoded, but not valid JSON or python literal")
          source = "base64"

      out_path.write_text(json.dumps(obj, ensure_ascii=True), encoding="utf-8")
      print(f"user_json normalized ({source}, {kind}) -> {out_path}")
      PY

      if [[ ! -s "$USER_JSON_PATH" ]]; then
        echo "ERROR: $USER_JSON_PATH missing/empty after decoding" >&2
        exit 2
      fi

      # Create users from user_json (hard fail on invalid schema)
      python3 - <<'PY'
      import json, os, re, sys, subprocess

      user_json_path = os.environ.get("USER_JSON_PATH", "/etc/dozilab/user.json")
      try:
          user_json = open(user_json_path, "r", encoding="utf-8").read().strip()
      except FileNotFoundError:
          user_json = ""
      force = str(os.environ.get("FORCE", "true")).lower() in ("1","true","yes","on")
      workdir = os.environ.get("WORKDIR","work")

      def fail(msg):
          print(msg, file=sys.stderr)
          sys.exit(1)

      if not re.match(r"^[A-Za-z0-9._-]{1,32}$", workdir or ""):
          print(f"Invalid workdir {workdir!r}, using 'work'")
          workdir = "work"

      if not user_json:
          fail("user_json is empty or missing")

      try:
          data = json.loads(user_json)
      except Exception as e:
          fail(f"user_json invalid: {e}. Must be JSON with double quotes.")

      if not isinstance(data, dict):
          fail("user_json must be a JSON object")

      instance = data.get("instance") or {}
      if not isinstance(instance, dict):
          fail("instance must be an object")

      credentials = instance.get("credentials") or []
      admin = instance.get("admin_credentials")
      apps = data.get("applications") or []

      if not isinstance(credentials, list):
          fail("instance.credentials must be a list")

      if not isinstance(apps, list):
          print("applications is not a list; ignoring")
          apps = []

      course_label = data.get("course_label") or ""
      if course_label:
          print(f"course_label={course_label}")

      if not credentials:
          print("WARNING: instance.credentials empty; no student users will be created")

      rx = re.compile(r"^[a-z_][a-z0-9_-]{0,31}$")

      def run(cmd, **kw):
          subprocess.run(cmd, check=True, **kw)

      NL = chr(10)

      def ensure_user(u, p, is_admin=False):
          if subprocess.run(["id", u], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL).returncode != 0:
              run(["useradd", "-m", "-s", "/bin/bash", u])

          # This MUST succeed, otherwise we fail the whole setup
          run(["chpasswd"], input=f"{u}:{p}" + NL, text=True)

          if is_admin:
              subprocess.run(["usermod", "-aG", "sudo", u], check=False)

          if force:
              subprocess.run(["chage", "-d", "0", u], check=False)

          run(["chmod", "700", f"/home/{u}"])
          run(["mkdir", "-p", f"/home/{u}/{workdir}"])
          run(["chown", "-R", f"{u}:{u}", f"/home/{u}/{workdir}"])
          run(["chmod", "700", f"/home/{u}/{workdir}"])

          profile = f"/home/{u}/.profile"
          line = f'cd "$HOME/{workdir}"' + NL
          try:
              txt = open(profile, "r", encoding="utf-8", errors="ignore").read()
          except FileNotFoundError:
              txt = ""
          if f'cd "$HOME/{workdir}"' not in txt:
              with open(profile, "a", encoding="utf-8") as f:
                  f.write(line)
          run(["chown", f"{u}:{u}", profile])

      created = []

      # Validate credentials upfront so we don't half-configure
      for idx, item in enumerate(credentials):
          if not isinstance(item, dict):
              fail(f"instance.credentials[{idx}] must be an object")
          u = item.get("username")
          p = item.get("password")
          if not isinstance(u, str) or not rx.match(u):
              fail(f"Invalid username: {u!r}")
          if not isinstance(p, str) or len(p) == 0:
              fail(f"Empty password for {u}")

      for item in credentials:
          u = item["username"]
          p = item["password"]
          ensure_user(u, p, is_admin=False)
          created.append(u)

      admin_user = None
      if admin is not None:
          if not isinstance(admin, dict):
              fail("instance.admin_credentials must be an object")
          au = admin.get("username")
          ap = admin.get("password")
          if not isinstance(au, str) or not rx.match(au):
              fail(f"Invalid admin username: {au!r}")
          if not isinstance(ap, str) or len(ap) == 0:
              fail("Empty password for admin user")
          ensure_user(au, ap, is_admin=True)
          admin_user = au

      # Restrict SSH users: ubuntu (admin key) + created users only
      allow_users = sorted(set(created + ([admin_user] if admin_user else [])))
      allow = "AllowUsers " + " ".join(["ubuntu"] + allow_users) + NL
      with open("/etc/ssh/sshd_config.d/98-dozilab-allowusers.conf", "w", encoding="utf-8") as f:
          f.write(allow)

      if allow_users:
          print("created users:", ", ".join(allow_users))

      if not apps:
          print("applications: none")
      else:
          for idx, app in enumerate(apps):
              if isinstance(app, dict):
                  name = app.get("name") or app.get("app") or f"index-{idx}"
                  version = app.get("version") or app.get("ver") or ""
                  if version:
                      print(f"applications[{idx}]: {name} {version}")
                  else:
                      print(f"applications[{idx}]: {name}")
              else:
                  print(f"applications[{idx}]: {app!r}")
      PY

      # Restart sshd; if this fails, trap will mark FAILED
      systemctl restart ssh || service ssh restart

      echo "multiuser setup finished $(date -Is)"

      # READY marker (ONLY here = success)
      msg="DOZILAB_READY stack=${STACK_LABEL} time=$(date -Is)"
      echo "$msg" | tee -a "$LOG" | tee /dev/console > "$READY_FILE"
      chmod 644 "$READY_FILE"

runcmd:
  - [ bash, -lc, "/usr/local/bin/dozilab-multiuser-setup.sh" ]

final_message: "DoziLab multi-user VM: cloud-init finished"
