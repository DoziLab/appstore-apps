#cloud-config
package_update: true
package_upgrade: false

write_files:
  - path: /etc/dozilab/user.json.payload
    owner: root:root
    permissions: "0600"
    content: |
      __USER_JSON__

  - path: /usr/local/bin/dozilab-postgres-setup.sh
    owner: root:root
    permissions: "0755"
    content: |
      #!/usr/bin/env bash
      set -euo pipefail
      export DEBIAN_FRONTEND=noninteractive

      LOG="/var/log/dozilab-postgres.log"
      MARK_DIR="/var/lib/dozilab"
      READY_FILE="${MARK_DIR}/ready"
      FAIL_FILE="${MARK_DIR}/failed"

      STACK_LABEL="__STACK_LABEL__"
      USER_JSON_PAYLOAD="/etc/dozilab/user.json.payload"
      USER_JSON_PATH="/etc/dozilab/user.json"

      mkdir -p "$MARK_DIR"
      exec > >(tee -a "$LOG") 2>&1

      on_fail() {
        rc=$?
        msg="DOZILAB_FAILED stack=${STACK_LABEL} rc=${rc} time=$(date -Is)"
        echo "$msg" | tee -a "$LOG" | tee /dev/console > "$FAIL_FILE"
        chmod 644 "$FAIL_FILE" || true
        exit "$rc"
      }
      trap on_fail ERR

      echo "DoziLab setup started $(date -Is)"
      echo "Stack label: ${STACK_LABEL}"
      echo "Using user_json payload: ${USER_JSON_PAYLOAD}"

      if [[ ! -s "$USER_JSON_PAYLOAD" ]]; then
        echo "ERROR: $USER_JSON_PAYLOAD missing/empty" >&2
        exit 2
      fi

      # ------------------------------------------------------------
      # Decode wrapper (base64 or raw) into JSON file, then validate payload.
      # Backend must send final db_user + database_name etc. (no sanitizing)
      # ------------------------------------------------------------
      python3 - <<'PY'
      import ast
      import base64
      import json
      import sys
      from pathlib import Path

      payload_path = Path("/etc/dozilab/user.json.payload")
      out_path = Path("/etc/dozilab/user.json")

      raw = payload_path.read_text(encoding="utf-8").strip()
      if not raw:
          sys.exit("user_json payload missing/empty")

      def parse_obj(txt: str):
          try:
              return json.loads(txt), "json"
          except Exception:
              pass
          try:
              return ast.literal_eval(txt), "python-literal"
          except Exception:
              return None, None

      def decode_b64(s: str):
          compact = "".join(s.split())
          pad = (-len(compact)) % 4
          compact += "=" * pad
          try:
              return base64.b64decode(compact, validate=True).decode("utf-8")
          except Exception:
              try:
                  return base64.b64decode(compact).decode("utf-8")
              except Exception:
                  return None

      obj, kind = parse_obj(raw)
      source = "raw"
      if obj is None:
          decoded = decode_b64(raw)
          if decoded is None:
              sys.exit("user_json payload is neither JSON/literal nor base64-encoded JSON/literal")
          obj, kind = parse_obj(decoded.strip())
          if obj is None:
              sys.exit("user_json base64 decoded, but not valid JSON or python literal")
          source = "base64"

      out_path.write_text(json.dumps(obj, ensure_ascii=True), encoding="utf-8")
      print(f"user_json normalized ({source}, {kind}) -> {out_path}")
      PY

      if [[ ! -s "$USER_JSON_PATH" ]]; then
        echo "ERROR: $USER_JSON_PATH missing/empty after decoding" >&2
        exit 2
      fi

      echo "Validating user_json schema (direct) ..."
      python3 - <<'PY'
      import json, re, sys

      p = "/etc/dozilab/user.json"
      data = json.load(open(p, "r", encoding="utf-8"))
      if not isinstance(data, dict):
          sys.exit("user_json must be an object")

      apps = data.get("applications")
      if not isinstance(apps, list):
          sys.exit("user_json.applications must be a list")

      def find_app(name: str):
          for a in apps:
              if isinstance(a, dict) and str(a.get("name","")).lower() == name:
                  return a
          return None

      pg = find_app("postgres") or find_app("postgresql")
      if not pg:
          sys.exit("Missing applications[name=postgres]")

      pg_creds = pg.get("credentials")
      if not isinstance(pg_creds, list) or not pg_creds:
          sys.exit("postgres.credentials must be a non-empty list")

      # strict identifiers to avoid surprises
      ident = re.compile(r"^[a-z_][a-z0-9_]{0,62}$")
      group_token = re.compile(r"^[A-Za-z0-9_]{1,32}$")

      used_db_users = set()

      for c in pg_creds:
          if not isinstance(c, dict):
              sys.exit("postgres.credentials entries must be objects")

          gid = c.get("group")
          if gid is None:
              sys.exit("postgres credential missing group")
          gid_s = str(gid).strip()
          if not gid_s or not group_token.match(gid_s):
              sys.exit(f"postgres credential group must be [A-Za-z0-9_], 1..32 chars, got: {gid!r}")

          dbn = c.get("database_name") or c.get("db_name")
          if not isinstance(dbn, str) or not ident.match(dbn):
              sys.exit(f"postgres credential database_name invalid (must match {ident.pattern}): {dbn!r}")

          db_user = c.get("db_user")
          if not isinstance(db_user, str) or not ident.match(db_user):
              sys.exit(f"postgres credential db_user invalid (must match {ident.pattern}): {db_user!r}")

          if db_user in used_db_users:
              sys.exit(f"duplicate postgres db_user not allowed: {db_user!r}")
          used_db_users.add(db_user)

          pw = c.get("password")
          if not isinstance(pw, str) or len(pw) < 6:
              sys.exit(f"postgres credential password too short for {db_user!r} (min 6)")

      admin = pg.get("admin_credentials") or {}
      if admin:
          if not isinstance(admin, dict):
              sys.exit("postgres.admin_credentials must be an object")
          a_user = admin.get("db_user")
          a_pw = admin.get("password")
          if not isinstance(a_user, str) or not ident.match(a_user):
              sys.exit(f"postgres admin db_user invalid (must match {ident.pattern}): {a_user!r}")
          if a_user in used_db_users:
              sys.exit(f"postgres admin db_user collides with group user: {a_user!r}")
          if not isinstance(a_pw, str) or len(a_pw) < 6:
              sys.exit("postgres admin password too short (min 6)")

      # pgadmin is optional; if present we validate only what it explicitly sends (no fallback)
      pga = find_app("pgadmin")
      if pga:
          pga_admin = pga.get("admin_credentials") or {}
          if not isinstance(pga_admin, dict) or not pga_admin.get("email") or not pga_admin.get("password"):
              sys.exit("pgadmin.admin_credentials must contain email+password when pgadmin app is present")

          pga_creds = pga.get("credentials")
          if not isinstance(pga_creds, list) or not pga_creds:
              sys.exit("pgadmin.credentials must be a non-empty list when pgadmin app is present")

          seen_emails = set()
          for c in pga_creds:
              if not isinstance(c, dict):
                  sys.exit("pgadmin.credentials entries must be objects")
              gid = c.get("group")
              if gid is None:
                  sys.exit("pgadmin credential missing group")
              gid_s = str(gid).strip()
              if not gid_s or not group_token.match(gid_s):
                  sys.exit(f"pgadmin credential group must be [A-Za-z0-9_], got: {gid!r}")

              email = c.get("email")
              pw = c.get("password")
              if not isinstance(email, str) or "@" not in email:
                  sys.exit(f"pgadmin credential email invalid: {email!r}")
              if not isinstance(pw, str) or len(pw) < 6:
                  sys.exit(f"pgadmin credential password too short for {email!r} (min 6)")
              if email in seen_emails:
                  sys.exit(f"duplicate pgadmin email not allowed: {email!r}")
              seen_emails.add(email)

      print("user_json validated OK (direct mode)")
      PY

      # ------------------------------------------------------------
      # Install PostgreSQL
      # - If user_json contains postgres_version -> install that major
      # - else install distro default (postgresql meta)
      # ------------------------------------------------------------
      PGVER="$(python3 - <<'PY'
      import json
      data = json.load(open("/etc/dozilab/user.json"))
      pgver = data.get("postgres_version")
      if pgver is None:
          pgver = data.get("postgresVersion")
      apps = data.get("applications") or []
      for a in apps:
          if isinstance(a, dict) and str(a.get("name","")).lower() in ("postgres","postgresql"):
              if a.get("postgres_version") is not None:
                  pgver = a.get("postgres_version")
              if a.get("postgresVersion") is not None:
                  pgver = a.get("postgresVersion")
      if pgver is None:
          print("")
      else:
          print(int(pgver))
      PY
      )"

      apt-get update -y
      if [[ -n "${PGVER}" ]]; then
        echo "Installing PostgreSQL ${PGVER} ..."
        apt-get install -y "postgresql-${PGVER}" postgresql-client
      else
        echo "Installing distro default PostgreSQL ..."
        apt-get install -y postgresql postgresql-client
      fi

      # Detect installed major version
      DETECTED_PGVER="$(pg_lsclusters --no-header 2>/dev/null | awk 'NR==1{print $1}')"
      if [[ -z "${DETECTED_PGVER:-}" ]]; then
        echo "ERROR: Could not detect Postgres version (pg_lsclusters empty)" >&2
        exit 3
      fi
      PGVER="${DETECTED_PGVER}"
      echo "Detected PostgreSQL major version: ${PGVER}"

      echo "Configuring Postgres to listen on localhost only ..."
      CONF="/etc/postgresql/${PGVER}/main/postgresql.conf"
      HBA="/etc/postgresql/${PGVER}/main/pg_hba.conf"

      sed -i "s/^#\\?listen_addresses\\s*=.*/listen_addresses = '127.0.0.1'/" "$CONF"

      grep -qE "^[[:space:]]*host[[:space:]]+all[[:space:]]+all[[:space:]]+127\\.0\\.0\\.1/32" "$HBA" \
        || echo "host all all 127.0.0.1/32 scram-sha-256" >> "$HBA"
      grep -qE "^[[:space:]]*host[[:space:]]+all[[:space:]]+all[[:space:]]+::1/128" "$HBA" \
        || echo "host all all ::1/128 scram-sha-256" >> "$HBA"

      systemctl enable --now postgresql
      systemctl restart postgresql

      for i in {1..60}; do
        if sudo -u postgres psql -d postgres -Atc "SELECT 1" >/dev/null 2>&1; then
          break
        fi
        sleep 1
      done

      # ------------------------------------------------------------
      # Provision DB roles & databases from user_json DIRECTLY
      # (robust quoting; no psql :var substitution)
      # ------------------------------------------------------------
      echo "Provisioning roles & databases (direct from user_json) ..."
      python3 - <<'PY'
      import json, subprocess, sys, re

      spec = json.load(open("/etc/dozilab/user.json"))
      apps = spec.get("applications") or []

      def find_app(name: str):
          for a in apps:
              if isinstance(a, dict) and str(a.get("name","")).lower() == name:
                  return a
          return None

      pg = find_app("postgres") or find_app("postgresql")
      pg_creds = pg.get("credentials") or []
      pg_admin = pg.get("admin_credentials") or {}

      ident = re.compile(r"^[a-z_][a-z0-9_]{0,62}$")
      group_token = re.compile(r"^[A-Za-z0-9_]{1,32}$")

      def run(sql: str, db: str = "postgres", capture: bool = True) -> str:
          cmd = ["sudo", "-u", "postgres", "psql", "-d", db, "-v", "ON_ERROR_STOP=1", "-Atc", sql]
          if capture:
              return subprocess.check_output(cmd, text=True, cwd="/").strip()
          subprocess.check_call(cmd, cwd="/")
          return ""

      def q_ident(s: str) -> str:
          return '"' + s.replace('"', '""') + '"'

      def q_lit(s: str) -> str:
          return "'" + s.replace("'", "''") + "'"

      def role_exists(name: str) -> bool:
          return run(f"SELECT 1 FROM pg_roles WHERE rolname={q_lit(name)};") == "1"

      def db_exists(name: str) -> bool:
          return run(f"SELECT 1 FROM pg_database WHERE datname={q_lit(name)};") == "1"

      def ensure_group_role(role: str) -> None:
          if not role_exists(role):
              run(f"CREATE ROLE {q_ident(role)} NOLOGIN;", capture=False)

      def ensure_login_role(role: str, password: str) -> None:
          if not role_exists(role):
              run(f"CREATE ROLE {q_ident(role)} LOGIN PASSWORD {q_lit(password)};", capture=False)
          else:
              run(f"ALTER ROLE {q_ident(role)} LOGIN PASSWORD {q_lit(password)};", capture=False)

      def ensure_db(dbname: str, owner: str) -> None:
          if not db_exists(dbname):
              run(f"CREATE DATABASE {q_ident(dbname)} OWNER {q_ident(owner)};", capture=False)
          run(f"ALTER DATABASE {q_ident(dbname)} OWNER TO {q_ident(owner)};", capture=False)

      def lock_down_db(dbname: str, grp_role: str) -> None:
          run(f"REVOKE ALL ON DATABASE {q_ident(dbname)} FROM PUBLIC;", capture=False)
          run(f"GRANT CONNECT, TEMPORARY ON DATABASE {q_ident(dbname)} TO {q_ident(grp_role)};", capture=False)
          run("REVOKE CREATE ON SCHEMA public FROM PUBLIC;", db=dbname, capture=False)
          run("REVOKE USAGE ON SCHEMA public FROM PUBLIC;", db=dbname, capture=False)
          run(f"GRANT USAGE, CREATE ON SCHEMA public TO {q_ident(grp_role)};", db=dbname, capture=False)

      def grant_group_defaults(dbname: str, creator_role: str, grp_role: str) -> None:
          run(
              f"ALTER DEFAULT PRIVILEGES FOR ROLE {q_ident(creator_role)} IN SCHEMA public "
              f"GRANT ALL PRIVILEGES ON TABLES TO {q_ident(grp_role)};",
              db=dbname,
              capture=False,
          )
          run(
              f"ALTER DEFAULT PRIVILEGES FOR ROLE {q_ident(creator_role)} IN SCHEMA public "
              f"GRANT ALL PRIVILEGES ON SEQUENCES TO {q_ident(grp_role)};",
              db=dbname,
              capture=False,
          )

      def grant_role(grp_role: str, user: str) -> None:
          run(f"GRANT {q_ident(grp_role)} TO {q_ident(user)};", capture=False)

      # Build group map (DIRECT): group -> {dbname, db_user, password}
      groups = {}
      for c in pg_creds:
          gid = str(c.get("group")).strip()
          if not gid or not group_token.match(gid):
              sys.exit(f"Invalid group token: {gid!r}")

          dbname = c.get("database_name") or c.get("db_name")
          db_user = c.get("db_user")
          pw = c.get("password")

          if not isinstance(dbname, str) or not ident.match(dbname):
              sys.exit(f"Invalid database_name for group {gid}: {dbname!r}")
          if not isinstance(db_user, str) or not ident.match(db_user):
              sys.exit(f"Invalid db_user for group {gid}: {db_user!r}")
          if not isinstance(pw, str) or len(pw) < 6:
              sys.exit(f"Invalid password for db_user {db_user!r} (min 6)")

          if gid in groups:
              sys.exit(f"Duplicate group in postgres.credentials: {gid!r}")
          groups[gid] = {"dbname": dbname, "db_user": db_user, "password": pw}

      # 1) group roles + dbs
      for gid, info in groups.items():
          grp_role = f"grp_{gid}"
          ensure_group_role(grp_role)
          ensure_db(info["dbname"], grp_role)
          lock_down_db(info["dbname"], grp_role)

      # 2) group login users
      for gid, info in groups.items():
          grp_role = f"grp_{gid}"
          db_user = info["db_user"]
          ensure_login_role(db_user, info["password"])
          grant_role(grp_role, db_user)
          grant_group_defaults(info["dbname"], db_user, grp_role)

      # 3) optional admin (teacher)
      if isinstance(pg_admin, dict) and pg_admin:
          a_user = pg_admin.get("db_user")
          a_pw = pg_admin.get("password")
          if a_user and a_pw:
              if not isinstance(a_user, str) or not ident.match(a_user):
                  sys.exit(f"Invalid postgres admin db_user: {a_user!r}")
              if not isinstance(a_pw, str) or len(a_pw) < 6:
                  sys.exit("Invalid postgres admin password (min 6)")
              ensure_login_role(a_user, a_pw)
              for gid, info in groups.items():
                  grp_role = f"grp_{gid}"
                  grant_role(grp_role, a_user)
                  grant_group_defaults(info["dbname"], a_user, grp_role)

      print(f"Provisioned groups: {len(groups)}")
      PY

      # ------------------------------------------------------------
      # pgAdmin (optional; only if applications includes pgadmin)
      # NO fallback, NO deriving from postgres.
      # ------------------------------------------------------------
      PGADMIN_PRESENT="$(python3 - <<'PY'
      import json
      spec = json.load(open("/etc/dozilab/user.json"))
      apps = spec.get("applications") or []
      def find(name):
          for a in apps:
              if isinstance(a, dict) and str(a.get("name","")).lower() == name:
                  return True
          return False
      print("true" if find("pgadmin") else "false")
      PY
      )"

      if [[ "$PGADMIN_PRESENT" == "true" ]]; then
        echo "Installing pgAdmin4 ..."
        apt-get install -y curl ca-certificates gnupg apache2 libapache2-mod-wsgi-py3
        install -d -m 0755 /etc/apt/keyrings
        curl -fsS https://www.pgadmin.org/static/packages_pgadmin_org.pub | gpg --dearmor -o /etc/apt/keyrings/pgadmin.gpg
        echo "deb [signed-by=/etc/apt/keyrings/pgadmin.gpg] https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/jammy pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list
        apt-get update -y
        apt-get install -y pgadmin4-web

        echo "Configuring pgAdmin admin account (direct) ..."
        python3 - <<'PY'
      import json, sys

      spec = json.load(open("/etc/dozilab/user.json"))
      apps = spec.get("applications") or []

      def get_app(name):
          for a in apps:
              if isinstance(a, dict) and str(a.get("name","")).lower() == name:
                  return a
          return None

      pga = get_app("pgadmin") or {}
      admin = pga.get("admin_credentials") or {}
      email = admin.get("email")
      pw = admin.get("password")

      if not email or not pw:
          sys.exit("pgadmin.admin_credentials missing email/password")
      if "@" not in email:
          sys.exit(f"pgAdmin admin email invalid: {email!r}")
      if len(pw) < 6:
          sys.exit("pgAdmin admin password too short (min 6)")

      open("/etc/default/pgadmin4", "w").write(
          f'PGADMIN_SETUP_EMAIL="{email}"\nPGADMIN_SETUP_PASSWORD="{pw}"\n'
      )
      print("pgAdmin admin email:", email)
      PY

        chmod 600 /etc/default/pgadmin4
        rm -f /var/lib/pgadmin/pgadmin4.db
        rm -rf /var/lib/pgadmin/sessions /var/lib/pgadmin/storage
        install -d -m 0750 -o www-data -g www-data /var/lib/pgadmin

        set -a
        source /etc/default/pgadmin4
        set +a
        PGADMIN_SETUP_EMAIL="$PGADMIN_SETUP_EMAIL" \
        PGADMIN_SETUP_PASSWORD="$PGADMIN_SETUP_PASSWORD" \
          /usr/pgadmin4/bin/setup-web.sh --yes

        a2enconf pgadmin4 || true
        systemctl reload apache2 || true

        echo "Creating pgAdmin users (direct from pgadmin.credentials) ..."
        python3 - <<'PY'
      import json, subprocess, sys

      spec = json.load(open("/etc/dozilab/user.json"))
      apps = spec.get("applications") or []

      def get_app(name):
          for a in apps:
              if isinstance(a, dict) and str(a.get("name","")).lower() == name:
                  return a
          return None

      pga = get_app("pgadmin") or {}
      creds = pga.get("credentials") or []
      if not isinstance(creds, list):
          sys.exit("pgadmin.credentials must be a list")

      accounts = []
      seen = set()
      for c in creds:
          if not isinstance(c, dict):
              continue
          email = c.get("email")
          pw = c.get("password")
          if not email or not pw:
              continue
          if email in seen:
              continue
          seen.add(email)
          accounts.append((email, pw))

      created = 0
      for email, pw in accounts:
          cmd = [
              "sudo",
              "-u",
              "www-data",
              "/usr/pgadmin4/venv/bin/python",
              "/usr/pgadmin4/web/setup.py",
              "add-user",
              email,
              pw,
              "--role",
              "User",
              "--active",
          ]
          res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
          out = (res.stdout or "").strip()
          if res.returncode == 0:
              created += 1
              print(f"created pgAdmin user: {email}")
          elif "already exists" in out.lower():
              print(f"pgAdmin user already exists: {email}")
          else:
              print(f"WARNING: failed to create pgAdmin user {email} rc={res.returncode}\n{out}")

      print(f"pgAdmin accounts processed: {len(accounts)}, created: {created}")
      PY
      fi

      msg="DOZILAB_READY stack=${STACK_LABEL} time=$(date -Is)"
      echo "$msg" | tee /dev/console > "$READY_FILE"
      chmod 644 "$READY_FILE"

      echo "DoziLab setup finished successfully"

runcmd:
  - [ bash, -lc, "/usr/local/bin/dozilab-postgres-setup.sh" ]

final_message: "DoziLab Postgres + pgAdmin VM: cloud-init finished"
